#extension GL_ARB_texture_rectangle : enable
#ifdef GL_EXT_gpu_shader4
#extension GL_EXT_gpu_shader4 : enable
#endif

uniform sampler2DRect infoPrevious;
uniform sampler2DRect infoCurrent;
uniform int layer;
uniform float viewportX;
uniform float viewportY;
uniform vec3 cameraPos;

uniform sampler3D volume[NQVTK_RAYCASTER_VOLUMECOUNT];
uniform float volumeDataShift[NQVTK_RAYCASTER_VOLUMECOUNT];
uniform float volumeDataScale[NQVTK_RAYCASTER_VOLUMECOUNT];
uniform vec3 volumeOrigin[NQVTK_RAYCASTER_VOLUMECOUNT];
uniform vec3 volumeSize[NQVTK_RAYCASTER_VOLUMECOUNT];
uniform vec3 volumeSpacing[NQVTK_RAYCASTER_VOLUMECOUNT];

uniform float tfStart[NQVTK_RAYCASTER_VOLUMECOUNT];
uniform float tfEnd[NQVTK_RAYCASTER_VOLUMECOUNT];

uniform float stepSize;
uniform float kernelSize;

uniform float testParam;

// Prototypes from LibUtility
bool getBit(float byte, int bit);
vec3 phongShading(vec3 matColor, vec3 normal);

// Get vector from volume
vec3 getVector(int v, vec3 pos) {
	vec4 tpos = gl_TextureMatrixInverse[v] * vec4(pos, 1.0);
	vec3 p = ((tpos.xyz / tpos.w) - volumeOrigin[v]) / volumeSize[v];
	return vec3(volumeDataShift[v]) + volumeDataScale[v] * texture3D(volume[v], p).xyz;
}

// Get raw value from volume (scaled / shifted to 0..1)
float getRawValue(int v, vec3 pos) {
	vec4 tpos = gl_TextureMatrixInverse[v] * vec4(pos, 1.0);
	vec3 p = ((tpos.xyz / tpos.w) - volumeOrigin[v]) / volumeSize[v];
	return texture3D(volume[v], p).x;
}

// Get actual value from volume
float getValue(int v, vec3 pos) {
	return volumeDataShift[v] + volumeDataScale[v] * getRawValue(v, pos);
}

// Gaussian kernel Jacobian
mat3 gaussianJacobian(int v, vec3 pos, float delta, vec3 val) {
	// TODO: kernelSize should be in world-space coords, not voxels
	float mini = floor(-2.0 * delta);
	float maxi = ceil(2.0 * delta);
	vec3 scale = vec3(delta) / volumeSpacing[v];
	vec3 f1 = 1.0 / (scale * 1.4142135623731);
	vec3 f2 = 1.0 / (scale * 2.506628274631); //sqrt(6.28318530717959)
	vec3 f3 = -1.0 / (2.0 * scale * scale);
	// TODO: this should be a 3D Gaussian derivative, not three 1D Gaussians
	// Find out the formula for that...
	vec3 dx = vec3(0.0);
	vec3 dy = vec3(0.0);
	vec3 dz = vec3(0.0);
	for (float i = mini; i < maxi + 1.0; ++i) {
		float j = -i;
		vec3 g = -f1 * (2.0 * j * f1) * f2 * exp(j * j * f3);
		dx += g.x * getVector(v, pos + vec3(i * volumeSpacing[v].x, 0.0, 0.0));
		dy += g.y * getVector(v, pos + vec3(0.0, i * volumeSpacing[v].y, 0.0));
		dz += g.z * getVector(v, pos + vec3(0.0, 0.0, i * volumeSpacing[v].z));
	}
	return mat3(dx, dy, dz) + mat3(1.0);
}

// Linear Jacobian
mat3 linearJacobian(int v, vec3 pos, float delta, vec3 val) {
#ifdef NQVTK_RAYCASTER_CENTRALDIFFERENCES
	vec3 dx = (getVector(v, pos + vec3(0.5 * delta, 0.0, 0.0)) - 
		getVector(v, pos - vec3(0.5 * delta, 0.0, 0.0))) / delta;
	vec3 dy = (getVector(v, pos + vec3(0.0, 0.5 * delta, 0.0)) - 
		getVector(v, pos - vec3(0.0, 0.5 * delta, 0.0))) / delta;
	vec3 dz = (getVector(v, pos + vec3(0.0, 0.0, 0.5 * delta)) - 
		getVector(v, pos - vec3(0.0, 0.0, 0.5 * delta))) / delta;
#else
	vec3 dx = (getVector(v, pos + vec3(delta, 0.0, 0.0)) - val) / delta;
	vec3 dy = (getVector(v, pos + vec3(0.0, delta, 0.0)) - val) / delta;
	vec3 dz = (getVector(v, pos + vec3(0.0, 0.0, delta)) - val) / delta;
#endif
	// Add identity (because we should have used pos + vec instead of vec)
	return mat3(dx, dy, dz) + mat3(1.0);
}

// Compute determinant of matrix
float determinant(mat3 m) {
	return m[0][0] * m[1][1] * m[2][2] 
		+ m[0][1] * m[1][2] * m[2][0] 
		+ m[0][2] * m[1][0] * m[2][1] 
		- m[0][2] * m[1][1] * m[2][0] 
		- m[0][1] * m[1][0] * m[2][2] 
		- m[0][0] * m[1][2] * m[2][1];
}

// Compute gradient of a scalar volume
vec3 linearRawScalarGradient(int v, vec3 pos, float delta, float val) {
#ifdef NQVTK_RAYCASTER_CENTRALDIFFERENCES
	float dx = (getRawValue(v, pos + vec3(0.5 * delta, 0.0, 0.0)) - 
		getRawValue(v, pos - vec3(0.5 * delta, 0.0, 0.0))) / delta;
	float dy = (getRawValue(v, pos + vec3(0.0, 0.5 * delta, 0.0)) - 
		getRawValue(v, pos - vec3(0.0, 0.5 * delta, 0.0))) / delta;
	float dz = (getRawValue(v, pos + vec3(0.0, 0.0, 0.5 * delta)) - 
		getRawValue(v, pos - vec3(0.0, 0.0, 0.5 * delta))) / delta;
#else
	float dx = (getRawValue(v, pos + vec3(delta, 0.0, 0.0)) - val) / delta;
	float dy = (getRawValue(v, pos + vec3(0.0, delta, 0.0)) - val) / delta;
	float dz = (getRawValue(v, pos + vec3(0.0, 0.0, delta)) - val) / delta;
#endif
	return vec3(dx, dy, dz);
}

// Adjust opacity for step length
float adjustOpacity(float val, float stepLength) {
	return 1.0 - pow(1.0 - val, stepLength);
}

float subrange(float val, float start, float end) {
	// Apply the volume's focus function
	float size = max(end - start, 0.00001);
	return clamp((val - start) / size, 0.0, 1.0);
}

vec3 streamlineShading(vec3 matColor, vec3 lineDir, vec3 position) {
	// Get to-eye vector
	vec3 toEye = normalize(cameraPos - position);
	// Get streamline normal
	vec3 streamlineNormal = toEye - abs(dot(toEye, lineDir)) * lineDir;
	// Compute lighting
	return phongShading(matColor, gl_NormalMatrix * streamlineNormal);
}

vec4 stripeTexture(vec3 vector, vec3 position, vec3 normal) {
	// Perpendicularness
	vec3 direction = normalize(vector);
	float f = abs(dot(direction, normal));
	vec3 stripecolor = f * vec3(1.0, 0.5, 0.0) + (1.0 - f) * vec3(0.0, 0.5, 1.0);
	// Magnitude
	float mag = clamp(
		length(vector / (volumeDataShift[0] + volumeDataScale[0])) * 1.25, 
		0.0, 1.0);
	stripecolor *= mag;
	// Striping
	vec4 tpos = gl_TextureMatrixInverse[0] * vec4(position, 1.0);
	vec3 p = ((tpos.xyz / tpos.w) - volumeOrigin[0]) / volumeSize[0];
	vec3 n = normal;
	// Instead of the noisy tangent plane, we project to the nearest axis-plane
	if (abs(n.x) > abs(n.y))
		if (abs(n.x) > abs(n.z))
			n = vec3(1.0, 0.0, 0.0);
		else
			n = vec3(0.0, 0.0, 1.0);
	else
		if (abs(n.y) > abs(n.z))
			n = vec3(0.0, 1.0, 0.0);
		else
			n = vec3(0.0, 0.0, 1.0);
	direction = direction - dot(direction, n) * n;
	vec3 v2 = cross(direction, n);
	float f2 = dot(p, v2);
	float stripe = mod(f2 * 20.0, 1.0);
	// TODO: smoothstep this
	if (stripe > 0.5) 
		stripe = 1.0;
	else
		stripe = 0.0;
	return vec4(stripecolor, stripe);
}

// Main shader function
void main() {
	// Get info
	vec4 r0 = gl_FragCoord;
	r0.x -= viewportX;
	r0.y -= viewportY;
	vec4 infoBefore = texture2DRect(infoPrevious, r0.xy);
	vec4 infoAfter = texture2DRect(infoCurrent, r0.xy);
	// No volumes to render in front of first layer
	if (layer == 0) discard;

	// Discard background
	if (length(infoAfter) == 0.0) discard;

	// Raycast this slab
	vec3 startPos = infoBefore.rgb;
	vec3 endPos = infoAfter.rgb;
	vec3 ray = endPos - startPos;

#ifdef NQVTK_RAYCASTER_DITHERPOS
	// Offset rays to reduce stepping artifacts
	float offset = abs(mod(r0.y, 4.0) - mod(r0.x, 4.0)) * 0.25 * stepSize;
	startPos += offset * normalize(ray);
#endif

	// Determine step, number of steps
	vec3 step = normalize(ray) * stepSize;
	float stepLength = stepSize;
	int numSteps = int(ceil(length(ray) / stepSize));

	// Determine active volumes
	bool active[NQVTK_RAYCASTER_VOLUMECOUNT];
	for (int v = 0; v < NQVTK_RAYCASTER_VOLUMECOUNT; ++v) {
		active[v] = getBit(infoBefore.a, v);
	}

	// Start tracing
	vec4 accum = vec4(vec3(0.0), 1.0);
	vec3 pos = startPos;

	// For each step along the ray...
	for (int i = 0; i < numSteps + 1; ++i) {
		// Information recorded for later stages
		vec3 vector = getVector(0, pos);
		float focusImportance = 0.0;
		vec3 focusColor = vec3(0.0);

#ifdef NQVTK_RAYCASTER_FOCUS
		// Volume 0 is our vector volume
		if (active[0]) {
			// Focus visualization
			mat3 jacobian = linearJacobian(0, pos, kernelSize, vector);
			float detJacobian = abs(determinant(jacobian));
			// TODO: make sure growth and shrinkage are symmetrical
			float growth = 0.0;
			if (detJacobian > 1.0) 
				growth = 1.0 - (1.0 / detJacobian);
			else
				growth = detJacobian - 1.0;
			focusColor = (growth > 0.0) ? vec3(0.3, 0.6, 1.0) : vec3(1.0, 0.9, 0.4);
			float value = abs(growth);
			
			float nongrowthdef = length(vector / (volumeDataScale[0] + volumeDataShift[0])) - value;
			nongrowthdef *= testParam;
			if (nongrowthdef > value) focusColor = vec3(1.0, 0.3, 0.0);
			value = max(value, nongrowthdef);
			
			focusImportance = subrange(value, tfStart[0], tfEnd[0]);
			focusColor *= focusImportance;
		}
#endif

		float deformation = length(vector / (volumeDataScale[0] + volumeDataShift[0]));

#ifdef NQVTK_RAYCASTER_DEFORM
		// Adjust pos for volume morphing
		// TODO: adjust for the transformation of the vector field
		vec3 position = pos + (testParam - 0.5) * 4.0 * vector;
#else
		vec3 position = pos;
#endif

		// Context information
		float contextImportance = 0.0;
		vec3 contextColor = vec3(0.0);

		// The other volumes are scalar volumes
		for (int v = 1; v < NQVTK_RAYCASTER_VOLUMECOUNT; ++v) {
			if (active[v]) {
				// TODO: Static context
				float value1 = getRawValue(v, position);
				float value2 = getRawValue(v, position + vector);

				vec3 gradient1 = linearRawScalarGradient(v, position, kernelSize, value1);
				vec3 gradient2 = linearRawScalarGradient(v, position + vector, kernelSize, value2);
				
				float gm1 = clamp(length(gradient1), 0.0, 1.0);
				float gm2 = clamp(length(gradient2), 0.0, 1.0);
				
				// TODO: Dynamic context
#ifdef NQVTK_RAYCASTER_SMEAR
				float value = 0.0;
				int n = 0;
				for (float i = 0.0; i <= 2.0 * testParam * length(vector); i += stepSize) {
					n++;
					vec3 smearpos = position + i * normalize(vector);
					value += subrange(getRawValue(v, smearpos), tfStart[v], tfEnd[v]);
				}
				value /= float(n);
#else
				float value = mix(
					subrange(value2 * gm2, tfStart[v], tfEnd[v]), 
					subrange(value1 * gm1, tfStart[v], tfEnd[v]), 
					testParam);
#endif
				//value = mix(value, subrange(value1, tfStart[v], tfEnd[v]), gm1);

				float dynamicness = subrange(deformation, testParam, 1.0);
				float contourness = 1.0 - subrange(
					abs(dot(normalize(cameraPos - position), gradient1)), 
					0.0, 0.1);
				value = subrange(
					contourness * gm1 * value1 * 5.0, 
					tfStart[v], tfEnd[v]);

				// TODO: implement proper transfer function support
				contextColor = mix(vec3(0.0, 1.0, 0.5), vec3(0.65), contourness);
				contextImportance = clamp(value, 0.0, 1.0);
			}
		} // for each scalar volume...

		// TODO: determine importance
		if (focusImportance > contextImportance) {
			// Use focus mode

			// TODO: texturing...

			// TODO: compute and apply lighting
			vec3 color = focusColor;
			float opacity = focusImportance;

#ifdef NQVTK_RAYCASTER_STREAMLINESHADING
			// Streamline shading test
			if (length(vector) > 0.0) {
				color = streamlineShading(color, normalize(vector), position);
			}
#endif

			// Compute correct opacity for blending
			opacity = adjustOpacity(opacity, stepLength);

			// Accumulate colors and opacities
			accum = vec4(
				accum.a * color * opacity + accum.rgb, 
				(1.0 - opacity) * accum.a);
		} else {
			// Use context mode

			// TODO: repeat for all scalar volumes...

			// TODO: this is not the right gradient...
			vec3 gradient = linearRawScalarGradient(1, 
				position, kernelSize, getRawValue(1, position));
			vec3 color = contextColor;
			float opacity = contextImportance;

			if (length(gradient) > 0.0) {
				vec3 normal = normalize(-gradient);
#ifdef NQVTK_RAYCASTER_STRIPING
				// Apply texture
				vec4 stripes = stripeTexture(vector, position, normal);
				color = stripes.a * stripes.rgb + (1.0 - stripes.a) * color;
#endif
#ifdef NQVTK_RAYCASTER_LIGHTING
				// Apply lighting
				color = phongShading(color, gl_NormalMatrix * normal);
#endif
			}

			// Compute correct opacity for blending
			opacity = adjustOpacity(opacity, stepLength);

			// Accumulate colors and opacities
			accum = vec4(
				accum.a * color * opacity + accum.rgb, 
				(1.0 - opacity) * accum.a);
		}

		// If alpha is (almost) saturated, terminate the ray
		if (accum.a < 0.001) i = numSteps + 1;

		// The last step should stay within the slab
		if (i == numSteps) {
			step = endPos - pos;
			stepLength = length(step);
		}

		// Step along the ray
		pos += step;

	} // for each step...

	// Colors are already pre-multiplied with alpha for slab compositing
	gl_FragColor = vec4(accum.rgb, 1.0 - accum.a);
}
