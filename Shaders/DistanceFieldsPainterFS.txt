#extension GL_ARB_texture_rectangle : enable
#ifdef GL_EXT_gpu_shader4
#extension GL_EXT_gpu_shader4 : enable
#endif

uniform sampler2DRect normals;
uniform sampler2DRect colors;
uniform sampler2DRect infoPrevious;
uniform sampler2DRect infoCurrent;
uniform int layer;
uniform float farPlane;
uniform float nearPlane;
uniform float viewportX;
uniform float viewportY;

// Parameters
uniform bool useFatContours;
uniform float contourDepthEpsilon;
uniform bool useFog;
uniform float depthCueRange;

// Prototypes from LibUtility
float unpackFloat(vec2 coded);
bool getBit(float byte, int bit);
vec3 phongShading(vec3 matColor, vec3 normal);

// Prototypes from LibCSG
bool CSG(float mask);
bool CSGFog(float mask);

// Main shader function
void main() {
	// Get info
	vec4 r0 = gl_FragCoord;
	r0.x -= viewportX;
	r0.y -= viewportY;
	vec3 normal = texture2DRect(normals, r0.xy).rgb;
	normal = (2.0 * normal) - vec3(1.0);
	vec4 color = texture2DRect(colors, r0.xy);
	vec4 info0 = texture2DRect(infoCurrent, r0.xy);
	vec4 info1 = texture2DRect(infoPrevious, r0.xy);
	if (layer == 0) info1 = vec4(0.0);

	// Apply lighting
	vec3 litFragment = phongShading(color.rgb, normal);

	// Apply CSG
	float mask0 = info0.y;
	float mask1 = info1.y;
	if (CSG(mask0) != CSG(mask1)) {
		color.a = 1.0;
	}

	// Apply contouring
	vec4 left	= texture2DRect(infoCurrent, vec2(r0.x - 1.0, r0.y));
	vec4 right	= texture2DRect(infoCurrent, vec2(r0.x + 1.0, r0.y));
	vec4 top	= texture2DRect(infoCurrent, vec2(r0.x, r0.y - 1.0));
	vec4 bottom	= texture2DRect(infoCurrent, vec2(r0.x, r0.y + 1.0));
	float depth	= unpackFloat(info0.zw);
	float diffL	= abs(unpackFloat(left.zw) - depth);
	float diffR	= abs(unpackFloat(right.zw) - depth);
	float diffT	= abs(unpackFloat(top.zw) - depth);
	float diffB	= abs(unpackFloat(bottom.zw) - depth);
	bool contourL = (left.x != info0.x && diffL < contourDepthEpsilon);
	bool contourR = (right.x != info0.x && diffR < contourDepthEpsilon);
	bool contourT = (top.x != info0.x && diffT < contourDepthEpsilon);
	bool contourB = (bottom.x != info0.x && diffB < contourDepthEpsilon);
	if (contourL || contourT || (useFatContours && (contourR || contourB))) {
		litFragment = vec3(0.0);
		color.a = 1.0;
	}

	// Clipping: objectId 2 is our clipping object
	// TODO: Clipping object should probably be configurable
	if (getBit(mask0, 2) && !getBit(mask1, 2)) {
		color.a = 0.0; // Just render the fog for this slab
	} else if ((getBit(mask0, 2) || getBit(mask1, 2))) {
		discard; // Nothing to render for this slab
	}

	// Apply fogging
	if (useFog && CSGFog(mask1)) {
		vec3 fogColor = vec3(1.0, 0.0, 0.2);
		float depthRange = (farPlane - nearPlane);
		float front = unpackFloat(info1.zw) * depthRange;
		float back = unpackFloat(info0.zw) * depthRange;
		float diff = back - front;
		float fogAlpha = 1.0 - 
			clamp(exp(-diff / depthCueRange), 0.0, 1.0);
		litFragment = fogColor * fogAlpha + 
			litFragment * color.a * (1.0 - fogAlpha);
		color.a = fogAlpha + color.a * (1.0 - fogAlpha);
		litFragment /= color.a;
	}

	// Pre-multiply colors by alpha
	litFragment *= color.a;
	gl_FragColor = vec4(litFragment, color.a);
}
