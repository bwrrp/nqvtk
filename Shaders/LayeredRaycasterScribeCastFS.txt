#extension GL_ARB_texture_rectangle : enable
#ifdef GL_EXT_gpu_shader4
#extension GL_EXT_gpu_shader4 : enable
#endif

uniform sampler2DRect infoPrevious;
uniform sampler2DRect infoCurrent;
uniform sampler2DRect normals;
uniform sampler2DRect colors;

uniform int layer;
uniform float viewportX;
uniform float viewportY;

uniform sampler3D volume[NQVTK_RAYCASTER_VOLUMECOUNT];
uniform float volumeDataShift[NQVTK_RAYCASTER_VOLUMECOUNT];
uniform float volumeDataScale[NQVTK_RAYCASTER_VOLUMECOUNT];
uniform vec3 volumeOrigin[NQVTK_RAYCASTER_VOLUMECOUNT];
uniform vec3 volumeSize[NQVTK_RAYCASTER_VOLUMECOUNT];
uniform vec3 volumeSpacing[NQVTK_RAYCASTER_VOLUMECOUNT];

uniform float tfStart[NQVTK_RAYCASTER_VOLUMECOUNT];
uniform float tfEnd[NQVTK_RAYCASTER_VOLUMECOUNT];

uniform float stepSize;
uniform float kernelSize;

// Prototypes from LibUtility
vec3 phongShading(vec3 matColor, vec3 normal);
bool getBit(float byte, int bit);
float setBit(float byte, int bit, bool on);

float getValue(vec3 pos, int v) {
	vec4 tpos = gl_TextureMatrixInverse[v] * vec4(pos, 1.0);
	vec3 p = ((tpos.xyz / tpos.w) - volumeOrigin[v]) / volumeSize[v];
	return texture3D(volume[v], p).x;
}

vec3 refineHitpoint(vec3 pos, vec3 step, int v, float isoval, bool belowAtPos) {
	vec3 s = 0.5 * step;
	vec3 p = pos - s;
	// 5 refinements should be enough for now
	for (int r = 0; r < 5; ++r) {
		float val = getValue(p, v);
		// Halve the step size
		s *= 0.5;
		// Step in which direction?
		if ((val < isoval) == belowAtPos) {
			p -= s;
		} else {
			p += s;
		}
	}
	return p;
}

void main() {
	// Get info
	vec4 r0 = gl_FragCoord;
	r0.x -= viewportX;
	r0.y -= viewportY;
	vec4 infoBefore = texture2DRect(infoPrevious, r0.xy);
	vec4 infoAfter = texture2DRect(infoCurrent, r0.xy);
	vec4 normalid = texture2DRect(normals, r0.xy);
	vec3 normal = normalize(normalid.rgb);
	float gm = length(normalid.rgb);
	float id = normalid.a;
	vec4 color = texture2DRect(colors, r0.xy);

	// Discard background
	if (length(infoAfter) == 0.0) discard;

	// Should be set to infoBefore if raycasting hits a surface
	vec4 info = infoAfter;

	// Raycast into the slab
	vec3 startPos = infoBefore.rgb;
	vec3 endPos = infoAfter.rgb;
	vec3 ray = endPos - startPos;

	// Determine step, number of steps
	vec3 step = normalize(ray) * stepSize;
	float stepLength = stepSize;
	int numSteps = int(ceil(length(ray) / stepSize));

	// Start raycasting
	vec3 pos = startPos;
	bool firstSample = true;
	float firstVal = 0.0;
	bool done = false;
	// For each step along the ray...
	for (int i = 0; i < numSteps + 1 && !done; ++i) {
		for (int v = 0; v < NQVTK_RAYCASTER_VOLUMECOUNT && !done; ++v) {
			// If the volume is active, sample it
			if (getBit(infoBefore.a, v)) {
				float val = getValue(pos, v);
				if (firstSample) {
					// The first sample can never hit a surface
					// TODO: we may want to use the in-out mask for this
					firstVal = val;
					firstSample = false;
				} else {
					if ((val < tfStart[v]) != (firstVal < tfStart[v])) {
						// Found an isosurface
						done = true;
						// TODO: if multiple volumes hit an isosurface, 
						//       check which is first by refinement
						pos = refineHitpoint(pos, step, v, tfStart[v], (val < tfStart[v]));
						// TODO: update in-out mask
						info = vec4(pos, infoBefore.a);
						color = vec4(vec3(1.0), 0.6);
						// TODO: compute normal
						normal = vec3(0.0);
					}
				}
			}
		}

		// The last step should stay within the slab
		if (i == numSteps) {
			step = endPos - pos;
			stepLength = length(step);
		}
		// Step along the ray
		pos += step;
	}

	// Fill the infobuffer
	gl_FragData[0] = info;
	gl_FragData[1] = vec4(normal, id);
	gl_FragData[2] = color;
}
