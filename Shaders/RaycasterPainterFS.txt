#extension GL_ARB_texture_rectangle : enable
#ifdef GL_EXT_gpu_shader4
#extension GL_EXT_gpu_shader4 : enable
#endif

uniform sampler2DRect infoPrevious;
uniform sampler2DRect infoCurrent;
uniform int layer;
uniform float viewportX;
uniform float viewportY;

uniform sampler3D volume[4];
uniform float volumeDataShift[4];
uniform float volumeDataScale[4];
uniform vec3 volumeOrigin[4];
uniform vec3 volumeSize[4];

// Prototypes from LibUtility
bool getBit(float byte, int bit);

// Main shader function
void main() {
	// Get info
	vec4 r0 = gl_FragCoord;
	r0.x -= viewportX;
	r0.y -= viewportY;
	vec4 infoBefore = texture2DRect(infoPrevious, r0.xy);
	vec4 infoAfter = texture2DRect(infoCurrent, r0.xy);
	if (layer == 0) discard;

	// Discard background
	if (length(infoAfter) == 0.0) discard;

	// Raycast this slab
	vec3 startPos = infoBefore.rgb;
	vec3 endPos = infoAfter.rgb;
	vec3 ray = endPos - startPos;
	// TODO: number of steps should be variable, step size constant
	const int N = 100;
	vec3 step = ray / float(N);
	float stepLength = length(step);
	// TODO: accumulate color and opacity as vec4
	vec4 accum = vec4(vec3(0.0), 1.0);
	vec3 pos = startPos;
	for (int i = 0; i < N; ++i) {
		float f = 0.0;
		for (int v = 0; v < 4; ++v) {
			if (getBit(infoBefore.a, v)) {
				// TODO: adjust pos for transforms (in gl_TextureMatrix[v])
				vec3 p = (pos - volumeOrigin[v]) / volumeSize[v];
				float val = texture3D(volume[v], p).x;
				// For now use the maximum value over all volumes
				f = max(f, val);
			}
		}
		// Map to colors and opacity
		// TODO: add transfer function support
		// TODO: this should probably be adjusted according to the step length...
		vec4 mapped = vec4(f);
		// Accumulate
		accum = vec4(accum.a * mapped.rgb * mapped.a + accum.rgb, (1.0 - mapped.a) * accum.a);
		// Step along the ray
		pos += step;
	}

	// Colors are already pre-multiplied with alpha for slab compositing
	gl_FragColor = vec4(accum.rgb, 1.0 - accum.a);
}
