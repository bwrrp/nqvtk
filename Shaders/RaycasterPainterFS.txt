#extension GL_ARB_texture_rectangle : enable
#ifdef GL_EXT_gpu_shader4
#extension GL_EXT_gpu_shader4 : enable
#endif

#define NQVTK_RAYCASTER_VOLUMECOUNT 4

uniform sampler2DRect infoPrevious;
uniform sampler2DRect infoCurrent;
uniform int layer;
uniform float viewportX;
uniform float viewportY;

uniform sampler3D volume[NQVTK_RAYCASTER_VOLUMECOUNT];
uniform float volumeDataShift[NQVTK_RAYCASTER_VOLUMECOUNT];
uniform float volumeDataScale[NQVTK_RAYCASTER_VOLUMECOUNT];
uniform vec3 volumeOrigin[NQVTK_RAYCASTER_VOLUMECOUNT];
uniform vec3 volumeSize[NQVTK_RAYCASTER_VOLUMECOUNT];

uniform float tfStart[NQVTK_RAYCASTER_VOLUMECOUNT];
uniform float tfEnd[NQVTK_RAYCASTER_VOLUMECOUNT];

uniform float stepSize;

uniform float testParam;

// Prototypes from LibUtility
bool getBit(float byte, int bit);
vec3 phongShading(vec3 matColor, vec3 normal);

// Get vector from volume
vec3 getVector(int v, vec3 pos) {
	vec4 tpos = gl_TextureMatrixInverse[v] * vec4(pos, 1.0);
	vec3 p = ((tpos.xyz / tpos.w) - volumeOrigin[v]) / volumeSize[v];
	return volumeDataShift[v] + volumeDataScale[v] * texture3D(volume[v], p).xyz;
}

// Compute Jacobian of vector volume
mat3 computeJacobian(int v, vec3 pos, float delta, vec3 val) {
#ifdef NQVTK_RAYCASTER_CENTRALDIFFERENCES
	vec3 dx = (getVector(v, pos + vec3(0.5 * delta, 0.0, 0.0)) - 
		getVector(v, pos - vec3(0.5 * delta, 0.0, 0.0))) / delta;
	vec3 dy = (getVector(v, pos + vec3(0.0, 0.5 * delta, 0.0)) - 
		getVector(v, pos - vec3(0.0, 0.5 * delta, 0.0))) / delta;
	vec3 dz = (getVector(v, pos + vec3(0.0, 0.0, 0.5 * delta)) - 
		getVector(v, pos - vec3(0.0, 0.0, 0.5 * delta))) / delta;
#else
	vec3 dx = (getVector(v, pos + vec3(delta, 0.0, 0.0)) - val) / delta;
	vec3 dy = (getVector(v, pos + vec3(0.0, delta, 0.0)) - val) / delta;
	vec3 dz = (getVector(v, pos + vec3(0.0, 0.0, delta)) - val) / delta;
#endif
	// Add identity (because we should have used pos + vec instead of vec)
	return mat3(dx, dy, dz) + mat3(1.0);
}

// Compute determinant of matrix
float determinant(mat3 m) {
	return m[0][0] * m[1][1] * m[2][2] 
		+ m[0][1] * m[1][2] * m[2][0] 
		+ m[0][2] * m[1][0] * m[2][1] 
		- m[0][2] * m[1][1] * m[2][0] 
		- m[0][1] * m[1][0] * m[2][2] 
		- m[0][0] * m[1][2] * m[2][1];
}

struct sample {
	float value;
	vec3 color;
#ifdef NQVTK_RAYCASTER_VECTORFIELD
	vec3 vector;
#endif
};

// Get color, value from volume
sample sampleVolume(int v, vec3 pos) {
	sample s;
#ifdef NQVTK_RAYCASTER_VECTORFIELD
	if (v == 0) {
		// Vector volume
		s.vector = getVector(v, pos);
		//float deformation = length(s.vector / 
		//	(volumeDataScale[v] + volumeDataShift[v]));
		mat3 jac = computeJacobian(v, pos, stepSize, s.vector);
		//float divergence = jac[0][0] + jac[1][1] + jac[2][2];
		//float convergence = max(0.0, -divergence);
		//divergence = max(0.0, divergence);
		float detJ = 1.0 / abs(determinant(jac));
		float growth = detJ - 1.0;
		float shrinkage = max(0.0, -growth);
		growth = max(0.0, growth);
		//float tot = divergence + convergence + 0.0001;
		float tot = growth + shrinkage + 0.0001;
		s.color = 
		//	deformation * vec3(1.0);
		//	divergence * vec3(1.0, 0.5, 0.0) + 
		//	convergence * vec3(0.0, 0.5, 1.0);
			growth * vec3(0.3, 0.6, 1.0) + 
			shrinkage * vec3(1.0, 0.9, 0.4);
		s.color /= tot;
		//s.value = deformation;
		//s.value = max(divergence, convergence);
		s.value = max(growth, shrinkage);
	} else {
#endif
#ifdef NQVTK_RAYCASTER_DEFORM
		// TODO: adjust for the transformation of the vector field
		pos += (testParam - 0.5) * 4.0 * getVector(0, pos);
#endif
		vec4 tpos = gl_TextureMatrixInverse[v] * vec4(pos, 1.0);
		vec3 p = ((tpos.xyz / tpos.w) - volumeOrigin[v]) / volumeSize[v];
		s.value = texture3D(volume[v], p).x;
		// TODO: adjust val by volumeData{Shift,Scale}[v]
		s.color = vec3(1.0) * s.value;
#ifdef NQVTK_RAYCASTER_VECTORFIELD
		s.vector = vec3(0.0);
	}
#endif
	return s;
}

// Get value from volume
float getValue(int v, vec3 pos) {
	return sampleVolume(v, pos).value;
}

// Compute gradient of the volume
vec3 computeGradient(int v, vec3 pos, float delta, float val) {
#ifdef NQVTK_RAYCASTER_CENTRALDIFFERENCES
	float dx = (getValue(v, pos + vec3(0.5 * delta, 0.0, 0.0)) - 
		getValue(v, pos - vec3(0.5 * delta, 0.0, 0.0))) / delta;
	float dy = (getValue(v, pos + vec3(0.0, 0.5 * delta, 0.0)) - 
		getValue(v, pos - vec3(0.0, 0.5 * delta, 0.0))) / delta;
	float dz = (getValue(v, pos + vec3(0.0, 0.0, 0.5 * delta)) - 
		getValue(v, pos - vec3(0.0, 0.0, 0.5 * delta))) / delta;
#else
	float dx = (getValue(v, pos + vec3(delta, 0.0, 0.0)) - val) / delta;
	float dy = (getValue(v, pos + vec3(0.0, delta, 0.0)) - val) / delta;
	float dz = (getValue(v, pos + vec3(0.0, 0.0, delta)) - val) / delta;
#endif
	return vec3(dx, dy, dz);
}

// Adjust opacity for step length
float adjustOpacity(float val, float stepLength) {
	return 1.0 - pow(1.0 - val, stepLength);
}

// Main shader function
void main() {
	// Get info
	vec4 r0 = gl_FragCoord;
	r0.x -= viewportX;
	r0.y -= viewportY;
	vec4 infoBefore = texture2DRect(infoPrevious, r0.xy);
	vec4 infoAfter = texture2DRect(infoCurrent, r0.xy);
	if (layer == 0) discard;

	// Discard background
	if (length(infoAfter) == 0.0) discard;

	// Raycast this slab
	vec3 startPos = infoBefore.rgb;
	vec3 endPos = infoAfter.rgb;
	vec3 ray = endPos - startPos;
	// Determine step, number of steps
	vec3 step = normalize(ray) * stepSize;
	float stepLength = stepSize;
	int numSteps = int(ceil(length(ray) / stepSize));
	// Start tracing
	vec4 accum = vec4(vec3(0.0), 1.0);
	vec3 pos = startPos;
	// For each step along the ray...
	for (int i = 0; i < numSteps + 1; ++i) {
		for (int v = 0; v < NQVTK_RAYCASTER_VOLUMECOUNT; ++v) {
			// If the volume is active, sample it
			if (getBit(infoBefore.a, v)) {
				sample s = sampleVolume(v, pos);

				// Apply the volume's transfer function
				// TODO: implement real transfer function support, remove this hack
				float tfSize = max(tfEnd[v] - tfStart[v], 0.00001);
				float opacity = clamp((s.value - tfStart[v]) / tfSize, 0.0, 1.0);

#ifdef NQVTK_RAYCASTER_LIGHTING
				// TODO: maybe we should compute gradients from the combined volumes?
				vec3 gradient = computeGradient(v, pos, stepSize, s.value);
				// Light this sample with this volume's gradient
				// TODO: normals should take slab boundaries into account
				//       ...but only in some cases (clipping planes!)
				if (length(gradient) > 0.0) {
					vec3 normal = normalize(gl_NormalMatrix * -gradient);

#ifdef NQVTK_RAYCASTER_STRIPING
					// Experimental perpendicularness
					float f = abs(dot(normalize(s.vector), normalize(-gradient)));
					vec3 stripecolor = f * vec3(1.0, 0.5, 0.0) + (1.0 - f) * vec3(0.0, 0.5, 1.0);
					// Experimental striping
					vec4 tpos = gl_TextureMatrixInverse[v] * vec4(pos, 1.0);
					vec3 p = ((tpos.xyz / tpos.w) - volumeOrigin[v]) / volumeSize[v];
					vec3 vec = normalize(s.vector);
					vec3 n = normalize(-gradient);
					// Instead of the noisy tangent plane, we project to the nearest axis-plane
					if (abs(n.x) > abs(n.y))
						if (abs(n.x) > abs(n.z))
							n = vec3(1.0, 0.0, 0.0);
						else
							n = vec3(0.0, 0.0, 1.0);
					else
						if (abs(n.y) > abs(n.z))
							n = vec3(0.0, 1.0, 0.0);
						else
							n = vec3(0.0, 0.0, 1.0);
					vec = vec - dot(vec, n) * n;
					vec3 v2 = cross(vec, n);
					float f2 = dot(p, v2);
					float stripe = mod(f2 * 20.0, 1.0);
					// TODO: smoothstep this
					if (stripe > 0.5) 
						stripe = 1.0;
					else
						stripe = 0.0;
					s.color = stripe * s.color + (1.0 - stripe) * stripecolor;
#endif

					s.color = phongShading(s.color, normal);
				}
#endif

				// Compute correct opacity for blending
				opacity = adjustOpacity(opacity, stepLength);

				// Accumulate colors and opacities
				accum = vec4(
					accum.a * s.color * opacity + accum.rgb, 
					(1.0 - opacity) * accum.a);
			}
		}

		/* Volume IBIS Test
		// TODO: move to separate shader?
		vec4 col = vec4(0.0);
		if (getBit(infoBefore.a, 0) && getBit(infoBefore.a, 1)) {
			float v0 = getValue(0, pos);
			float v1 = getValue(1, pos);
			vec4 col0 = vec4(vec3(1.0, 0.9, 0.4), mapValue(v0, stepLength).a);
			vec4 col1 = vec4(vec3(0.3, 0.6, 1.0), mapValue(v1, stepLength).a);
			vec3 gmin, gmax;
			vec4 colmin, colmax;
			if (v0 > v1) {
				colmin = col1; colmax = col0;
				gmin = computeGradient(1, pos, stepSize, v1);
				gmax = computeGradient(0, pos, stepSize, v0);
			} else {
				colmin = col0; colmax = col1;
				gmin = computeGradient(0, pos, stepSize, v0);
				gmax = computeGradient(1, pos, stepSize, v1);
			}
			// Adjust outer
			colmax.a = colmax.a / 30.0;
			if (colmax.a > colmin.a) {
				col = colmax;
				g = gmax;
			} else {
				col = colmin;
				g = gmin;
			}
		} else if (getBit(infoBefore.a, 0)) {
			float v0 = getValue(0, pos);
			col = vec4(vec3(1.0, 0.9, 0.4), mapValue(v0, stepLength).a);
			// Adjust outer
			col.a = col.a / 30.0;
			g = computeGradient(0, pos, stepSize, v0);
		} else if (getBit(infoBefore.a, 1)) {
			float v1 = getValue(1, pos);
			col = vec4(vec3(0.3, 0.6, 1.0), mapValue(v1, stepLength).a);
			// Adjust outer
			col.a = col.a / 30.0;
			g = computeGradient(1, pos, stepSize, v1);
		}
		//*/

		// If alpha is (almost) saturated, terminate the ray
		if (accum.a < 0.001) i = numSteps + 1;
		// The last step should stay within the slab
		if (i == numSteps) {
			step = endPos - pos;
			stepLength = length(step);
		}
		// Step along the ray
		pos += step;
	}

	// Colors are already pre-multiplied with alpha for slab compositing
	gl_FragColor = vec4(accum.rgb, 1.0 - accum.a);
}
