#extension GL_ARB_texture_rectangle : enable
#ifdef GL_EXT_gpu_shader4
#extension GL_EXT_gpu_shader4 : enable
#endif

uniform sampler2DRect infoPrevious;
uniform sampler2DRect infoCurrent;
uniform int layer;
uniform float viewportX;
uniform float viewportY;

uniform sampler3D volume;
uniform float volumeDataShift;
uniform float volumeDataScale;
uniform vec3 volumeOrigin;
uniform vec3 volumeSize;

// Prototypes from LibUtility
bool getBit(float byte, int bit);

// Main shader function
void main() {
	// Get info
	vec4 r0 = gl_FragCoord;
	r0.x -= viewportX;
	r0.y -= viewportY;
	vec4 infoBefore = texture2DRect(infoPrevious, r0.xy);
	vec4 infoAfter = texture2DRect(infoCurrent, r0.xy);
	if (layer == 0) discard;

	// Discard background
	if (length(infoAfter) == 0.0) discard;

	// Just testing...
	const int N = 100;
	float accum = 0.0;
	vec3 startPos = infoBefore.rgb;
	vec3 endPos = infoAfter.rgb;
	vec3 ray = endPos - startPos;
	// TODO: adjust for transforms?
	vec3 pos = startPos;
	vec3 step = ray / float(N);
	for (int i = 0; i < N; ++i) {
		vec3 p = (pos - volumeOrigin) / volumeSize;
		float f = texture3D(volume, p).x;
		accum = max(accum, f);
		pos += step;
	}
	gl_FragColor = vec4(accum);
}
