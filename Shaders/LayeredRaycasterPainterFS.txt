#extension GL_ARB_texture_rectangle : enable
#ifdef GL_EXT_gpu_shader4
#extension GL_EXT_gpu_shader4 : enable
#endif

uniform sampler2DRect infoPrevious;
uniform sampler2DRect infoCurrent;
uniform sampler2DRect normals;
uniform sampler2DRect colors;

uniform int layer;
uniform float viewportX;
uniform float viewportY;

uniform sampler3D volume[NQVTK_RAYCASTER_VOLUMECOUNT];
uniform float volumeDataShift[NQVTK_RAYCASTER_VOLUMECOUNT];
uniform float volumeDataScale[NQVTK_RAYCASTER_VOLUMECOUNT];
uniform vec3 volumeOrigin[NQVTK_RAYCASTER_VOLUMECOUNT];
uniform vec3 volumeSize[NQVTK_RAYCASTER_VOLUMECOUNT];
uniform vec3 volumeSpacing[NQVTK_RAYCASTER_VOLUMECOUNT];

uniform float tfStart[NQVTK_RAYCASTER_VOLUMECOUNT];
uniform float tfEnd[NQVTK_RAYCASTER_VOLUMECOUNT];

uniform float testParam;

uniform float occlusionEdgeThreshold;
uniform float cornerEdgeThreshold;

// Prototypes from LibUtility
vec3 phongShading(vec3 matColor, vec3 normal);
bool getBit(float byte, int bit);

float stripes(float f, int size, int part) {
	return int(f) % size < part ? 0.0 : 1.0;
}

float plusTexture(vec2 c) {
	return 1.0 - stripes(c.x, 20, 8) * stripes(c.y, 20, 8) * 
		(1.0 - stripes(c.x + 8.0, 20, 4) * stripes(c.y + 8.0, 20, 4));
}

float stripeTexture(vec2 c) {
	return stripes(abs(c.x + c.y), 20, 8);
}

void main() {
	// Get info
	vec4 r0 = gl_FragCoord;
	r0.x -= viewportX;
	r0.y -= viewportY;
	vec4 infoBefore = texture2DRect(infoPrevious, r0.xy);
	if (layer == 0) infoBefore = vec4(0.0);
	vec4 infoAfter = texture2DRect(infoCurrent, r0.xy);
	vec4 normalid = texture2DRect(normals, r0.xy);
	vec3 normal = normalize(normalid.rgb);
	float gm = length(normalid.rgb);
	float id = normalid.a;
	vec4 color = texture2DRect(colors, r0.xy);

	if (layer < int(testParam * 100.0)) discard;

	// Some extra coloring effects for volume features
	if (length(infoBefore) > 0.0) {
		if (int(id) == 2) color.rgb = vec3(1.0, 0.5, 0.0);
		if (int(id) == 3) color.rgb = vec3(0.0, 0.5, 1.0);
		if ((getBit(infoBefore.a, 2) && getBit(infoBefore.a, 3)) != 
			(getBit(infoAfter.a, 2) && getBit(infoAfter.a, 3))) {
			color.a = 1.0;
		} else if (int(id) == 2 || int(id) == 3) {
			color.rgb = mix(color.rgb, vec3(1.0), 0.5);
		}
	}

	// Simple lighting
	if (gm > 0.0) color = vec4(phongShading(color.rgb, normal), color.a);

	// Test: screen-space textures for visualizing ids
	if (int(id) == 2) {
		color.rgb *= (0.5 + 0.5 * stripeTexture(r0.xy));
	} else if (int(id) == 3) {
		color.rgb *= (0.5 + 0.5 * plusTexture(r0.xy));
	}

	// Apply contouring
	vec4 left	= texture2DRect(normals, vec2(r0.x - 1.0, r0.y));
	vec4 right	= texture2DRect(normals, vec2(r0.x + 1.0, r0.y));
	vec4 top	= texture2DRect(normals, vec2(r0.x, r0.y - 1.0));
	vec4 bottom	= texture2DRect(normals, vec2(r0.x, r0.y + 1.0));
	bool contourL = (left.a   != id);
	bool contourR = (right.a  != id);
	bool contourT = (top.a    != id);
	bool contourB = (bottom.a != id);
	if (contourL || contourT || contourR || contourB) {
		color = vec4(vec3(0.0), 1.0);
	} else {
		// Test for occlusion edges (depth difference)
		// TODO: these positions are not refined surface hits!
		float leftDepth = length(
			texture2DRect(infoCurrent, vec2(r0.x - 1.0, r0.y)).rgb - 
			infoAfter.rgb);
		float rightDepth = length(
			texture2DRect(infoCurrent, vec2(r0.x + 1.0, r0.y)).rgb - 
			infoAfter.rgb);
		float topDepth = length(
			texture2DRect(infoCurrent, vec2(r0.x, r0.y - 1.0)).rgb - 
			infoAfter.rgb);
		float bottomDepth = length(
			texture2DRect(infoCurrent, vec2(r0.x, r0.y + 1.0)).rgb - 
			infoAfter.rgb);
		if (abs(leftDepth - rightDepth) > occlusionEdgeThreshold || 
			abs(topDepth - bottomDepth) > occlusionEdgeThreshold) {
			// Occlusion edge
			color = vec4(0.0, 0.0, 0.3, 1.0);
		} else if (abs(dot(normalize(left.rgb), normal)) < cornerEdgeThreshold || 
			abs(dot(normalize(right.rgb), normal)) < cornerEdgeThreshold || 
			abs(dot(normalize(top.rgb), normal)) < cornerEdgeThreshold || 
			abs(dot(normalize(bottom.rgb), normal)) < cornerEdgeThreshold) {
			// Corner edge
			color = vec4(0.0, 0.3, 0.0, 1.0);
		}
	}

	// Premultiply colors
	gl_FragColor = vec4(color.rgb * color.a, color.a);
}
