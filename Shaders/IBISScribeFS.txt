#extension GL_ARB_texture_rectangle : enable
#extension GL_ARB_draw_buffers : enable
#ifdef GL_EXT_gpu_shader4
#extension GL_EXT_gpu_shader4 : enable
#endif

uniform sampler2DRectShadow depthBuffer;
uniform sampler2DRect infoBuffer;
uniform int layer;
uniform int objectId;

varying vec3 normal;
varying vec4 color;
varying float depthInCamera;

// Rounds a float to the nearest integer
#ifndef GL_EXT_gpu_shader4
float round(float x) {
	return floor(x + 0.5);
}
#endif

// Encodes a bit set in a float, range [0..1]
float setBit(float byte, int bit, bool on) {
#ifdef GL_EXT_gpu_shader4
// - gpu-shader4, use bitwise operators
	float N = 4.0;
	float max = pow(2.0, N) - 1.0;
	int pattern = int(round(byte * max));
	int mask = 1 << bit;
	if (on) {
		pattern = pattern | mask;
	} else {
		pattern = pattern & ~mask;
	}
	return float(pattern) / max;
#else
// - no gpu-shader4, use float arith for bit masks
	float f = 2.0;
	float N = 4.0;
	float max = pow(f, N) - 1.0;
	byte = round(byte * max);
	float bf = pow(f, float(bit));
	float b = fract(byte / bf);
	float af = bf * f;
	float a = floor(byte / af);
	float r = bf * b + af * a;
	if (on) r += f / 2.0 * bf;
	return r / max;
#endif
}

// Gets a single bit from a float-encoded bit set
bool getBit(float byte, int bit) {
#ifdef GL_EXT_gpu_shader4
// - gpu-shader4, use bitwise operators
	float N = 4.0;
	float max = pow(2.0, N) - 1.0;
	int pattern = int(round(byte * max));
	int mask = 1 << bit;
	return (pattern & mask) != 0;
#else
// - no gpu-shader4, use float arith for bit masks
	float f = 2.0;
	float N = 4.0;
	if (bit > int(N)) return false;
	float mask = round(byte * (pow(f, N) - 1.0)) / f;
	int i;
	for (i = 0; i <= bit - 1; ++i) {
		mask = floor(mask) / f;
	}
	return (fract(mask) > 0.25);
#endif
}

// Packs a float in two 8 bit channels
vec2 encodeDepth(float depth) {
	depth = clamp(depth, 0.0, 1.0);
	vec2 factors = vec2(1.0, 256.0);
	vec2 result = fract(depth * factors);
	result.x -= result.y / factors.y;
	return result;
}

// Shader main function
void main() {
	vec4 r0 = gl_FragCoord;
	vec4 col = color;

	// Depth peeling
	if (layer > 0) {
		float r1 = shadow2DRect(depthBuffer, r0.xyz).x;
		r1 = r1 - 0.5;
		if (r1 < 0.0) { discard; }
	}

	// Get the previous info buffer
	vec4 prevInfo = vec4(0.0);
	if (layer > 0) {
		prevInfo = texture2DRect(infoBuffer, r0.xy);
	}

	// Coplanarity peeling
	if (getBit(prevInfo.y, objectId) == gl_FrontFacing) {
		discard;
	}

	// Encode identity
	float id = float(objectId) + 1.0;
	if (id < 0.0) id = 0.0;
	float identity = id / 9.0;
	// Encode in-out mask
	float inOutMask = prevInfo.y;
	if (objectId >= 0) {
		inOutMask = setBit(inOutMask, objectId, gl_FrontFacing);
	}
	// Encode depth
	vec2 depthVec = encodeDepth(depthInCamera);
	// Encode normal
	vec3 n = (normalize(normal) + vec3(1.0)) / 2.0;
	// Store data
	gl_FragData[0] = col;
	gl_FragData[1] = vec4(n, 1.0);
	gl_FragData[2] = vec4(identity, inOutMask, depthVec);
}
